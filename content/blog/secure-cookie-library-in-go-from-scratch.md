---
title: "Secure cookie library in Go from scratch"
date: 2025-02-06
slug: "secure-cookie-library-in-go-from-scratch"
summary: In this post, I show you how to write a "secure cookie" library that will encrypt and authenticate payloads using the XChaCha20-Poly1305 AEAD, using the Go programming language.
lang: en
---

### Introduction: What are cookies and why should I care?

Cookies are short[^1] strings of letters, digits, and symbols[^2] that a Web server may store in your browser.
They are used to identify a user of a given Website between requests.
Whenever you add a product to a virtual shopping cart or sign in to an online mailbox, that Website is going to give you a _cookie_ that the server can later use to identify you.

The name _cookie_ comes from the term _magic cookie_[^3], which predates the World Wide Web and refers to a value passed between programs unchanged.
This is similar to a [fortune cookie &#x1F960;](https://en.wikipedia.org/wiki/Fortune_cookie), which also contains a hidden message that can be passed around.

Cookies are an essential part of any Web application, and if you live in Europe, chances are you are going to be reminded about this fact every single day. There is a browser extension to fix that[^4].

In this article, I'm going to teach you how to implement a cookie-based session store using the [Go programming language](https://go.dev/) and an [authenticated encryption](https://en.wikipedia.org/wiki/Authenticated_encryption) scheme called [XChaCha20-Poly1305](https://en.wikipedia.org/wiki/ChaCha20-Poly1305).

But first, before we talk about the <em>how</em>s, we need to talk about the <em>why</em>s. Like, have you ever wondered _what exactly_ is stored in that cookie?

### Naïve Approach: Just Store the Value

Let us go back to the example of a virtual shopping cart. On the server, there is likely a database table called `carts`. When you put an item in the cart, the server will create a new row in that table (a "new cart"). Let's say that your cart has the ID of `42`.

The simplest approach is to just store the cart ID in the cookie:

```http
HTTP/1.1 200 OK
Set-Cookie: cart_id=42
...
```

Then, when you visit your cart again, you send the cookie back to the server:

```http
GET /cart HTTP/1.1
Cookie: cart_id=42
...
```

In a perfect world, this would work just fine! However, in a non-perfect world, this approach is going to be terribly insecure.

For starters, the cart ID is generated in a sequence (1, 2, 3, ...), making it trivial to guess the next and previous identifier.
Even worse, this ID is all that is needed to forge a cookie and fetch someone else's cart.

With such poor security, a malicious actor (or just a curious bystander) could hack your Website and fetch _all data_ in _all carts_, using just a `for` loop:

```c
for (int i = 1; i <= 42; i++) {
    hack_the_website(i);
}
```

Not great! What can we do to remedy this? The short answer is: We need to make the cookie _much_ harder to guess.

### Approach One: A Random String

One approach to this problem is to use a long, random string.
Any data that actually matters is then stored on the server, in a so-called **session**.
This approach has been popularized by the popular PHP programming language, which introduced this feature back in 2000, with the release of [version 4.0.0](https://www.php.net/ChangeLog-4.php#PHP_4_0).
In PHP, by default, the session data is stored in encrypted text files, but there also exist adapters for relational databases, such as PostgreSQL or SQLite, or data stores, such as Redis or Memcached.
Since all the important data is already stored on the server, revoking a session is very easy&mdash;deleting the session data on the server is enough to invalidate the cookie.

### Approach Two: Sign Your Cookies

Another way is to store all the necessary data inside the cookie. In order to ensure that the cookie was really generated by our server, the data needs to be either **authenticated** using a shared secret or **cryptographically signed** using a private key.

**Authentication** is performed using a [Message Authentication Code](https://en.wikipedia.org/wiki/Message_authentication_code) (MAC) algorithm, which is based on a [hash function](https://en.wikipedia.org/wiki/Cryptographic_hash_function).
A MAC uses the same key for signing a value and for verification, meaning that the key must be kept secret. The most commonly used MAC is [HMAC-SHA256](https://en.wikipedia.org/wiki/HMAC), which is based on the [SHA-2](https://en.wikipedia.org/wiki/SHA-2) hashing algorithm.

By contrast, a **digital signature** uses two keys: a **private key**, which must be kept secret, and a **public key** that we can reveal to anyone.
The private key is used to sign messages, while the public key can only be used to verify an existing signature.
A popular digital signature scheme is [EdDSA](https://en.wikipedia.org/wiki/EdDSA), commonly used in the variant known as **Ed25519**.
If you have an account on Github, chances are that you are already using EdDSA signatures to upload and download code over [SSH](https://en.wikipedia.org/wiki/Secure_Shell).

### Approach Three: Encrypt Your Cookies, Then Sign Them

Both MACs and digital signature schemes guarantee that a cookie cannot be forged or tampered with, but the actual value stored in the cookie is still stored in plaintext.
If you also wish to hide the value from nosy users, you need to **encrypt** it first, e. g. using a cipher like [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard).

AES is a [block cipher](https://en.wikipedia.org/wiki/Block_cipher), meaning that in its purest form, it can only encrypt a single block at a time.
In the case of AES, the block size is 16 bytes or 128 bits.
If the message you need to encrypt is longer than a single block, you need to figure up an algorithm to let you securely apply the cipher over multiple blocks of data.
Several such algorithms were designed, and collectively, they are called [modes of operation](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation).
Two modes of operation have made their way to modern TLS implementations: **Cipher Block Chaining** (CBC) and **Galois Counter Mode** (GCM).

#### AES-CBC (Cipher Block Chaining)

The CBC mode of operation was patented back in 1976[^5]. In this mode of operation, each block of data is combined with another value using [XOR](https://en.wikipedia.org/wiki/Exclusive_or) before passing through the block cipher. For the first block of plaintext, a unique value called an **initialization vector** (IV) is used, and for each subsequent block of data, the previous block of ciphertext is used. The length of the message must be a multiple of the block size, meaning that shorter messages need to be padded with additional data.

The CBC mode only deals with the _encryption_ of data, providing **confidentiality**, which means that the encrypted message cannot be read by anyone without the secret key. It is not concerned with _authentication_, therefore it needs to be used in combination with a MAC to ensure the integrity and authenticity of a message.

The CBC mode, although undeniably clever, is currently considered insecure and its usage in TLS 1.2 has been deprecated. The most recent revision of TLS, version 1.3, does not use the CBC mode of operation at all. This solves a whole lot of vulnerabilities in the protocol, making it much harder to eavesdrop on TLS-encrypted traffic. TLS 1.3 is therefore banned in China[^6].

#### AES-GCM (Galois Counter Mode)

The Galois Counter Mode (GCM) mode of operation is a much later invention than the CBC mode of operation, with the initial paper by McGrew and Viega[^7] published in 2004[^8].
AES in Galois Counter Mode does not encrypt the data at all.
Instead, for each encrypted message, a unique value is used. The GCM spec calls it an _initialization vector_, just like CBC, but they are also colloquially referred to as **nonces** (short for _number once_).
The IV in GCM does not need to be random. In fact, you can even use sequential numbers, as long as you can guarantee that a given value will never be reused (easier said than done). For AES-GCM, the nonce is _usually_ 96 bits (12 bytes).

GCM is an **authenticated encryption** scheme, meaning that it guarantees not only the privacy of a message, but also its authenticity.
An authenticated encryption scheme therefore seems like a perfect choice for use in cookies.
AES-GCM also supports adding some extra information about the message (e. g. the HTTP origin of the website or the name of the cookie it is stored in).
It is therefore called an **authenticated encryption with associated data** (AEAD) scheme.

GCM differs from CBC in that in GCM mode, you do not encrypt the message, you only encrypt the IV and a counter.
Let me explain how this works in practice.

Let's say your plaintext is 2137 bytes long. With a block size of 16 bytes, we need to encrypt _2137 / 16 = 133.5625 ≈ 134_ blocks of data.
Then, pick a nonce, let's say, the number 42. Encoded in 96 bits, big-endian, it looks like this:

```
00 00 00 00 00 00 00 00 00 00 00 2A
```

The remaining 32 bits of each block contain the block counter. For the first block of plaintext, we use the number 1, and for the last one, the number 134:

```
# first block (index = 1)
00 00 00 00 00 00 00 00 00 00 00 2A 00 00 00 01

# last block (index = 134)
00 00 00 00 00 00 00 00 00 00 00 2A 00 00 00 89
```

In order to encrypt 134 blocks of plaintext, encrypt each of these blocks using the encryption key.
Since the output of AES encryption for a single block is always 16 bytes long, we can calculate that encrypting 134 blocks will yield <em>134 &times; 16 = 2144</em> bytes of random-looking data, which we could probably call a *keystream*[^13]. Then, since the resulting binary is longer than the plaintext, we can discard the last 7 bytes of the mask. Then, combine the plaintext with the mask using XOR.

Since XOR is a reversible operation, when decrypting a message encrypted with AES-GCM, we perform the exact same operation to generate the mask, and this mask, combined with the ciphertext using XOR, should return the plaintext.

In contrast with the CBC mode of operation, in which the ciphertext of the previous block is combined with each following block, in GCM mode, there is no dependency between blocks.
This implies that you can compute these in parallel and in any order you want, allowing for all sorts of optimizations.

Now, you may ask: where did the block with the index 0 go?
This block is not used in the encryption process, it is only used for authentication.
If you want to know exactly how this algorithm works, you can read the original proposal by David A. McGrew and John Viega[^7].

### The Random Nonce Problem

As mentioned above, the nonce used in AES-GCM mode is 96 bits long and must not be reused.
In theory, that gives us 2<sup>96</sup> possible nonces, which should be more than enough for unlimited use by all of humanity and Santi people[^16], until the [Universe dies of hypothermia](https://en.wikipedia.org/wiki/Heat_death_of_the_universe).

Unfortunately, due to a phenomenon called the [birthday problem](https://en.wikipedia.org/wiki/Birthday_problem), if you generate nonces using a random (or pseudo-random) number generator, the risk of a nonce collision increases greatly.

For this reason, the National Institute of Standards and Technology[^9] recommends that:

> The total number of invocations of the authenticated encryption function shall not exceed
> 2<sup>32</sup>, including all IV lengths and all instances of the authenticated encryption function with
> the given key.

Now, 2<sup>32</sup> is definitely not a small number, but now the risk of a nonce collision is much higher than the original, naïve estimate of 2<sup>&minus;96</sup>.
We could choose to simply ignore this issue. After all, who is going to sit around and submit the login form 2<sup>32</sup> times to trigger a nonce collision in our signed cookie implementation?

We could also implement a key rotation scheme, for instance, rotating the key every _n_ days, to ensure that the 96-bit nonces _really_ do not collide. Now, securely rotating encryption keys is a great challenge in and of itself. Mind you, it may be hard to calculate how _often_, exactly, you would need to rotate the key. If it's just for a side project, the answer is most likely going to be: _never_. However, for some services at scale, the threshold of 2<sup>32</sup> invocations could well be reached within a single day. There ought to be a better way!

### Introducing XChaCha20-Poly1305

There are ways to deal with the nonce reuse problem in AES-GCM, the most notable of them being [AES-GCM-SIV](https://en.wikipedia.org/wiki/AES-GCM-SIV).
AES-GCM-SIV achieves this property by deriving an initialization vector for the AEAD based on the provided nonce, the additional authenticated data, and the entirety of the plaintext. This, however, requires going over the whole plaintext twice: Once to derive an IV, and once to encrypt the plaintext.

The XChaCha-Poly1305 AEAD was built as an alternative solution. Unlike AES-GCM, which is based on the block cipher AES, it is based on a stream cipher called ChaCha20.
designed with the specific goal of being resistant to nonce reuse in mind. XChaCha20 uses 192-bit nonces, which can safely be generated randomly.

### Implementing our `securecookie` library

Create a directory for the project. I called my library `securecookie`, inspired by [gorilla/securecookie](https://github.com/gorilla/securecookie), but you may pick a different name[^14]. However, you may want to make sure the package name does not collide with popular packages from the standard library, such as `http` or `context`, as that would be very inconvenient for the end user.

```shell
mkdir securecookie
```

Initialize a new Go project. You may want to replace `moroz` with your username.

```shell
cd securecookie
go mod init github.com/moroz/securecookie
```

Install the [golang.org/x/crypto/chacha20poly1305](https://pkg.go.dev/golang.org/x/crypto@v0.32.0/chacha20poly1305) library. It contains the cryptographic primitives that we will use to encrypt, decrypt, and authenticate messages.

```shell
go get -u golang.org/x/crypto/chacha20poly1305
```

Create a new file called `securecookie.go`. In this file, let's start by defining a few constants, which we will use when implementing the hard part (the part with actual cryptography):

```go
package securecookie

import "golang.org/x/crypto/chacha20poly1305"

const (
	KeySize   = chacha20poly1305.KeySize
	NonceSize = chacha20poly1305.NonceSizeX
	Overhead  = chacha20poly1305.Overhead
)
```

The names of the `KeySize` and `NonceSize` constants are rather self-explanatory. Note that the nonce size is equal to a constant called `NonceSizeX`, with an `X` at the end. The `X` at the end indicates that this is the size of a nonce in XChaCha20-Poly1305, which is 192 bits or 24 bytes, unlike regular ChaCha20-Poly1305, whose nonce is 96 bits long.
The constant called `Overhead` corresponds to the size of the authentication tag, or the checksum that will be appended at the end of the authenticated ciphertext.

#### Define the `Store` interface

Now, let us step back for a moment and think about the actual functionality that we want to implement.
What we need is a library that can encrypt and authenticate an arbitrary binary string and serialize it to a format that can be safely stored in a cookie[^2].
Then, we would also need a way to decrypt and verify the message loaded from a cookie.

These requirements can be expressed as the following interface:

```go
type Store interface {
	// Encrypt encrypts and authenticates the given plaintext and produces a binary
	// message that contains all the information necessary to verify it.
	Encrypt(plaintext []byte) (msg []byte, err error)

	// Decrypt decrypts and verifies a binary message and returns the original
	// binary plaintext.
	Decrypt(msg []byte) (plaintext []byte, err error)

	// EncryptCookie encrypts the given plaintext and produces a string that can be
	// safely stored in an HTTP cookie.
	EncryptCookie(plaintext []byte) (cookie string, err error)

	// DecryptCookie decodes a cookie generated by `EncryptCookie` and returns
	// the original binary plaintext.
	DecryptCookie(cookie string) (plaintext []byte, err error)
}
```

#### Implement a `store` struct

Now, let us implement a concrete type to implement this interface. We can start by defining a simple `struct` to store the secret key.

```go
type store struct {
	key []byte
}
```

Since this type is not exported, we can only use it if we also define a constructor function. We can use this opportunity to validate the length of the provided secret key:

```go
var ErrKeySize = errors.New("Invalid key size")

func NewStore(key []byte) (Store, error) {
	if len(key) != KeySize {
		return nil, fmt.Errorf("%w %d (want %d)", ErrKeySize, len(key), KeySize)
	}

	return &store{key: key}, nil
}
```

An interesting observation is that even though we defined the return type as `(Store, error)`, returning `nil, error` still satisfies the Go compiler. This is because an interface value can be backed by a `nil` concrete value[^15] (but you would still get a panic if you tried to call a method on a `nil` value).

#### `Encrypt`: encrypts and authenticates binary data

At this point, this code is not terribly helpful. We can't event test it, because the `store` type does not implement any of the four methods defined in our `interface Store`.
Let us start with the encryption part.

```go
// import "crypto/rand"

// Encrypt encrypts and authenticates the binary plaintext with the secret key.
func (s *store) Encrypt(plaintext []byte) ([]byte, error) {
	// Allocate buffer with the initial size just big enough to generate a random nonce,
	// but with capacity for the whole message (nonce + ciphertext + authentication tag)
	nonce := make([]byte, NonceSize, NonceSize+len(plaintext)+Overhead)

	// Generate a random nonce. `rand.Read` will only generate as much data as can fit
    // within the initial size of the slice
	rand.Read(nonce)

    // Initialize an XChaCha20-Poly1305 AEAD with the secret key
	aead, err := chacha20poly1305.NewX(s.key)
	if err != nil {
		return nil, fmt.Errorf("Encrypt: %w", err)
	}

	// Encrypt and authenticate the message
	msg := aead.Seal(nonce, nonce, plaintext, nil)

    // The return value is nonce + ciphertext + authentication tag in one byte slice
	return msg, nil
}
```

Let us analyze the code bit by bit.

```go
nonce := make([]byte, NonceSize, NonceSize+len(plaintext)+Overhead)
```

First, we allocate a buffer with the initial length of `NonceSize` bytes, but with capacity for the whole authenticated message.
Later on, this byte slice will contain not just the nonce&hellip; but the ciphertext, and the authentication tag, too.

```go
rand.Read(nonce)
```

Then, we generate a random nonce (initialization vector) using [`rand.Read`](https://pkg.go.dev/crypto/rand#Read).
Since we set the initial length of the `nonce` slice to `NonceSize`, we can be sure that the nonce generated using will be exactly `NonceSize` bytes long. This is because under the hood, `rand.Read` uses [`io.ReadFull`](https://pkg.go.dev/io#ReadFull) to copy random data from [`rand.Reader`](https://pkg.go.dev/crypto/rand#Reader).
According to its documentation, the `io.ReadFull` function "&hellip;reads exactly `len(buf)` bytes&hellip;", which will be equal to the second argument passed to `make`.

```go
aead, err := chacha20poly1305.NewX(s.key)
if err != nil {
    return nil, fmt.Errorf("Encrypt: %w", err)
}
```

Then, we initialize a new XChaCha20-Poly1305 AEAD with the secret key.
The `chacha20poly1305.NewX` function's first return value is an interface type called [`cipher.AEAD`](https://pkg.go.dev/crypto/cipher#AEAD).
This interface has two methods that are of interest to us:

```go
type AEAD interface {
        // Seal encrypts and authenticates plaintext, authenticates the
        // additional data and appends the result to dst, returning the updated
        // slice.
        // ...
        Seal(dst, nonce, plaintext, additionalData []byte) []byte

        // Open decrypts and authenticates ciphertext, authenticates the
        // additional data and, if successful, appends the resulting plaintext
        // to dst, returning the updated slice. The nonce must be NonceSize()
        // bytes long and both it and the additional data must match the
        // value passed to Seal.
        // ...
        Open(dst, nonce, ciphertext, additionalData []byte) ([]byte, error)
}
```

Based on this interface, I understand the AEAD to use the metaphor of a sealed letter: While a letter is sealed, no-one, not even the person who sealed it, can read it or modify its content.
At the same time, a proper seal guarantees that the message really comes from the purported sender.
Analogously, a message encrypted and authenticated with an AEAD is sealed from prying eyes and it cannot be modified.

This is how we use `Seal` in our `Encrypt` method:

```go
msg := aead.Seal(nonce, nonce, plaintext, nil)
```

This call will encrypt and authenticate the `plaintext` using `nonce`, writing the result to the byte slice currently used by the `nonce`.
We pass `nil` to the last argument, `additionalData`, indicating that we do not wish to use any additional authenticated data.

```go
return msg, nil
```

Finally, we return the message and `nil`, indicating that there was no error.

#### `Decrypt` decrypts and verifies the provided message

The next step is implementing the `Decrypt` method to decode and verify AEAD-encrypted messages. Unsurprisingly, in this method, we are going to use the `Open` method of the `cipher.AEAD` interface:

```go
var ErrMsgTooShort = errors.New("encrypted message too short")

// Decrypt decrypts and verifies the provided message in the format: nonce+ciphertext+authentication tag.
// Returns verified plaintext and error, if any.
func (s *store) Decrypt(message []byte) ([]byte, error) {
	if len(message) < NonceSize+Overhead {
		return nil, fmt.Errorf("%w (got %v, want %v or more)",
			ErrMsgTooShort, len(message), NonceSize+Overhead)
	}

	nonce, ciphertext := message[:NonceSize], message[NonceSize:]
	aead, err := chacha20poly1305.NewX(s.key)
	if err != nil {
		return nil, fmt.Errorf("Decrypt: %w", err)
	}

	return aead.Open(nil, nonce, ciphertext, nil)
}
```

Let us analyze this method in detail.

First, we validate that the message is long enough to be a valid AEAD-encrypted message:

```go
if len(message) < NonceSize+Overhead {
    return nil, fmt.Errorf("%w (got %v, want %v or more)",
        ErrMsgTooShort, len(message), NonceSize+Overhead)
}
```

If the message is to short, we return a wrapped error containing detailed information about the discrepancy (as in: `got 12, want 40 or more`).

By design, any message encrypted with `Encrypt` has the combined length of its plaintext, the nonce (initialization vector), and the authentication tag.
As per the ChaCha20-Poly1305 spec[^17], on which XChaCha20-Poly1305 is based, both the plaintext and the additional associated data can be of arbitrary length, including zero length.
This implies that the minimal length of a valid AEAD-authenticated message is nonce size + length of the authentication tag.
While a malformed message would have been rejected by the AEAD implementation, we need to validate the length of the encrypted message to ensure the correct execution of the following line:

```go
nonce, ciphertext := message[:NonceSize], message[NonceSize:]
```

Split the message into the nonce and the remainder (ciphertext with authentication tag).
This operation would cause a panic (_runtime error: slice bounds out of range_) if we tried to perform it on an input value shorter than `NonceSize`.

```go
aead, err := chacha20poly1305.NewX(s.key)
if err != nil {
    return nil, fmt.Errorf("Decrypt: %w", err)
}
```

Initialize a `cipher.AEAD` the same way as in `Encrypt`.

```go
return aead.Open(nil, nonce, ciphertext, nil)
```

Finally, &ldquo;open&rdquo; the &ldquo;sealed letter.&rdquo;
On success, return the authenticated plaintext as a byte slice and an empty error (`nil`).
On failure, return an empty slice (`nil`) and the error returned by `Open`.

#### `EncryptCookie` encrypts plaintext and produces a cookie

Until now, we have been dealing exclusively with byte slices rather than actual cookies. The `EncryptCookie` method wraps the `Encrypt` method to produce an encrypted that can securely be stored in a cookie. Luckily, this is very easy to do:

```go
// import "encoding/base64"

// EncryptCookie encrypts plaintext and produces a cookie
func (s *store) EncryptCookie(plaintext []byte) (string, error) {
	msg, err := s.Encrypt(plaintext)
	if err != nil {
		return "", err
	}

	return base64.RawURLEncoding.EncodeToString(msg), nil
}
```

Let us quickly go over each step. First, we call `Encrypt`:

```go
msg, err := s.Encrypt(plaintext)
if err != nil {
    return "", err
}
```

If the call to `Encrypt` fails for some reason, return an empty string and the original error.

```go
return base64.RawURLEncoding.EncodeToString(msg), nil
```

Finally, encode the binary message to `base64url`[^18], without padding. Regular `base64` encoding would work as well: The only difference between `base64` and `base64url` is that the latter uses `-` and `_` in place of `+` and `/`. However, all four are valid in cookies[^2]. The choice of one or the other is thus a matter of personal preference, and I prefer `base64url`.

#### `DecryptCookie` decrypts and verifies cookie and returns plaintext

The only remaining method required by our `Store` interface is `DecryptCookie`, which performs the inverse of `EncryptCookie`. Its implementation is equally straightforward:

```go
// DecryptCookie decrypts and verifies cookie and returns plaintext
func (s *store) DecryptCookie(cookie string) ([]byte, error) {
	msg, err := base64.RawURLEncoding.DecodeString(cookie)
	if err != nil {
		return nil, fmt.Errorf("DecryptCookie: %w", err)
	}

	return s.Decrypt(msg)
}
```

First, decode the cookie using the same encoding scheme as used in `EncryptCookie`:

```go
msg, err := base64.RawURLEncoding.DecodeString(cookie)
if err != nil {
    return nil, fmt.Errorf("DecryptCookie: %w", err)
}
```

In the case of an error, I opted to wrap the error value with the name of the calling function.
This error may be triggered by any malformed input, and for that reason, I believe it is much more likely to occur than an unspecified encryption error.
Adding this prefix may help pinpoint the source of the issue during debugging.

Finally, call `Decrypt` to decrypt and verify the message:

```go
return s.Decrypt(msg)
```

On success, this call will return the verified plaintext.

[^1]: As a [rule of thumb](http://browsercookielimits.iain.guru/), the maximum size of all cookies stored for a domain should not exceed around 4 kB (4096 bytes).

[^2]: According to [RFC 6265](https://httpwg.org/specs/rfc6265.html#sane-set-cookie), all the characters permitted within a cookie are: `A`&ndash;`Z`, `a`&ndash;`z`, `0`&ndash;`9`, and the following: <code>!#$%&'()&#x2a;+-./:&lt;=&gt;?@[]^&#x5F;&#x60;{|}~</code>. Note that spaces, double quotes&nbsp;(`"`), and semicolons&nbsp;(`;`) are not permitted.

[^3]: Stuart, A. (2002). *Where cookie comes from.* Retrieved January 14, 2025, from [http://dominopower.com/article/where-cookie-comes-from/](http://dominopower.com/article/where-cookie-comes-from/).

[^4]: If you are tired of obnoxious cookie banners, you can hide them using the browser extension _I still don't care about cookies_ (available for [Chrome/Edge](https://chromewebstore.google.com/detail/i-still-dont-care-about-c/edibdbjcniadpccecjdfdjjppcpchdlm) and [Firefox](https://addons.mozilla.org/en-US/firefox/addon/istilldontcareaboutcookies/)).

[^5]: Ehrsam, W. F., Meyer, C. H. W., Smith, J. L., & Tuchman, W. L. (1976). *Message verification and transmission error detection by block chaining.* US Patent 4074066.

[^6]: Cimpanu, C. (2020). *China is now blocking all encrypted HTTPS traffic that uses TLS 1.3 and ESNI.* ZDNet. Retrieved January 16, 2025, from [https://www.zdnet.com/article/china-is-now-blocking-all-encrypted-https-traffic-using-tls-1-3-and-esni/](https://www.zdnet.com/article/china-is-now-blocking-all-encrypted-https-traffic-using-tls-1-3-and-esni/).

[^7]: McGrew, D. A., & Viega, J. (n.d.). *The Galois/Counter Mode of Operation (GCM).* Retrieved January 17, 2025, from [https://luca-giuzzi.unibs.it/corsi/Support/papers-cryptography/gcm-spec.pdf](https://luca-giuzzi.unibs.it/corsi/Support/papers-cryptography/gcm-spec.pdf).

[^8]: Or maybe 2005. I have not found a conclusive source.

[^9]: Dworkin, M. (2007). *Recommendation for block cipher modes of operation: Galois/Counter Mode (GCM) and GMAC (NIST SP 800-38D).* National Institute of Standards and Technology. Retrieved January 19, 2025, from [https://doi.org/10.6028/NIST.SP.800-38D](https://doi.org/10.6028/NIST.SP.800-38D).

[^10]: I don't think it's an official cryptographic term, but it seems logical enough to me. Then again, _I'm not a lawyer_.

[^11]: Internet Engineering Task Force (IETF). (2015). *RFC 7539: ChaCha20 and Poly1305 for IETF protocols.* Retrieved January 20, 2025, from [https://www.rfc-editor.org/rfc/rfc7539](https://www.rfc-editor.org/rfc/rfc7539)

[^12]: It does state that a 96-bit nonce is the most efficient due to the way CPUs process data (they operate on 32-bit words).

[^13]: In a similar context, the ChaCha20 spec calls it a _keystream_. ChaCha20 is a stream cipher, unlike AES, so I'm not sure if the wording can be used interchangeably.

[^14]: For instance, you may pick `securebiscuit` if you are from the UK.

[^15]: Go Programming Language Specification. (n.d.). *Interface types*. Retrieved January 25, 2025, from [https://go.dev/ref/spec#Interface_types](https://go.dev/ref/spec#Interface_types)

[^16]: [https://en.wikipedia.org/wiki/The_Three-Body_Problem_(novel)](https://en.wikipedia.org/wiki/The_Three-Body_Problem_(novel)), [https://baike.baidu.com/item/三体人/8709210](https://baike.baidu.com/item/%E4%B8%89%E4%BD%93%E4%BA%BA/8709210) (Chinese).

[^17]: IETF. (2018). *RFC 8439: ChaCha20 and Poly1305 for IETF protocols*. Internet Engineering Task Force. Retrieved February 6, 2025, from [https://datatracker.ietf.org/doc/html/rfc8439#section-2.8](https://datatracker.ietf.org/doc/html/rfc8439#section-2.8).

[^18]: IETF. (2006). *RFC 4648: The Base16, Base32, and Base64 Data Encodings*. Internet Engineering Task Force. Retrieved February 6, 2025, from [https://datatracker.ietf.org/doc/html/rfc4648#section-5](https://datatracker.ietf.org/doc/html/rfc4648#section-5).

