---
title: "Secure cookie library in Go from scratch"
date: 2025-01-14
slug: "secure-cookie-library-in-go-from-scratch"
summary: In this post, I show you how to write a "secure cookie" library in Go using AEAD cryptographic primitives.
lang: en
draft: yes
---

### Introduction: What are cookies and why should I care?

Cookies are short[^1] strings of letters, digits, and symbols[^2] that a Web server may store in your browser.
They are used to identify a user of a given Website between requests.
Whenever you add a product to a virtual shopping cart or sign in to an online mailbox, that Website is going to give you a _cookie_ that the server can later use to identify you.

The name _cookie_ comes from the term _magic cookie_[^3], which predates the World Wide Web and refers to a value passed between programs unchanged.
This is similar to a [fortune cookie &#x1F960;](https://en.wikipedia.org/wiki/Fortune_cookie), which also contains a hidden message that can be passed around.

Cookies are an essential part of any Web application, and if you live in Europe, chances are you are going to be reminded about this fact every single day. There is a browser extension to fix that[^4].

In this article, I'm going to teach you how to implement a cookie-based session store using the [Go programming language](https://go.dev/) and an [authenticated encryption](https://en.wikipedia.org/wiki/Authenticated_encryption) scheme called [XChaCha20-Poly1305](https://en.wikipedia.org/wiki/ChaCha20-Poly1305).

But first, before we talk about the <em>how</em>s, we need to talk about the <em>why</em>s. Like, have you ever wondered _what exactly_ is stored in that cookie?

### Naïve Approach: Just Store the Value

Let us go back to the example of a virtual shopping cart. On the server, there is likely a database table called `carts`. When you put an item in the cart, the server will create a new row in that table (a "new cart"). Let's say that your cart has the ID of `42`.

The simplest approach is to just store the cart ID in the cookie:

```http
HTTP/1.1 200 OK
Set-Cookie: cart_id=42
...
```

Then, when you visit your cart again, you send the cookie back to the server:

```http
GET /cart HTTP/1.1
Cookie: cart_id=42
...
```

In a perfect world, this would work just fine! However, in a non-perfect world, this approach is going to be terribly insecure.

For starters, the cart ID is generated in a sequence (1, 2, 3, ...), making it trivial to guess the next and previous identifier.
Even worse, this ID is all that is needed to forge a cookie and fetch someone else's cart.

With such poor security, a malicious actor (or just a curious bystander) could hack your Website and fetch _all data_ in _all carts_, using just a `for` loop:

```c
for (int i = 1; i <= 42; i++) {
    hack_the_website(i);
}
```

Not great! What can we do to remedy this? The short answer is: We need to make the cookie _much_ harder to guess.

### Approach One: A Random String

One approach to this problem is to use a long, random string.
Any data that actually matters is then stored on the server, in a so-called **session**.
This approach has been popularized by the popular PHP programming language, which introduced this feature back in 2000, with the release of [version 4.0.0](https://www.php.net/ChangeLog-4.php#PHP_4_0).
In PHP, by default, the session data is stored in encrypted text files, but there also exist adapters for relational databases, such as PostgreSQL or SQLite, or data stores, such as Redis or Memcached.
Since all the important data is already stored on the server, revoking a session is very easy&mdash;deleting the session data on the server is enough to invalidate the cookie.

### Approach Two: Sign Your Cookies

Another way is to store all the necessary data inside the cookie. In order to ensure that the cookie was really generated by our server, the data needs to be either **authenticated** using a shared secret or **cryptographically signed** using a private key.

**Authentication** is performed using a [Message Authentication Code](https://en.wikipedia.org/wiki/Message_authentication_code) (MAC) algorithm, which is based on a [hash function](https://en.wikipedia.org/wiki/Cryptographic_hash_function).
A MAC uses the same key for signing a value and for verification, meaning that the key must be kept secret. The most commonly used MAC is [HMAC-SHA256](https://en.wikipedia.org/wiki/HMAC), which is based on the [SHA-2](https://en.wikipedia.org/wiki/SHA-2) hashing algorithm.

By contrast, a **digital signature** uses two keys: a **private key**, which must be kept secret, and a **public key** that we can reveal to anyone.
The private key is used to sign messages, while the public key can only be used to verify an existing signature.
A popular digital signature scheme is [EdDSA](https://en.wikipedia.org/wiki/EdDSA), commonly used in the variant known as **Ed25519**.
If you have an account on Github, chances are that you are already using EdDSA signatures to upload and download code over [SSH](https://en.wikipedia.org/wiki/Secure_Shell).

### Approach Three: Encrypt Your Cookies, Then Sign Them

Both MACs and digital signature schemes guarantee that a cookie cannot be forged or tampered with, but the actual value stored in the cookie is still stored in plaintext.
If you also wish to hide the value from nosy users, you need to **encrypt** it first, e. g. using a cipher like [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard).

AES is a [block cipher](https://en.wikipedia.org/wiki/Block_cipher), meaning that in its purest form, it can only encrypt a single block at a time.
In the case of AES, the block size is 16 bytes or 128 bits.
If the message you need to encrypt is longer than a single block, you need to figure up an algorithm to let you securely apply the cipher over multiple blocks of data.
Several such algorithms were designed, and collectively, they are called [modes of operation](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation).
Two modes of operation have made their way to modern TLS implementations: **Cipher Block Chaining** (CBC) and **Galois Counter Mode** (GCM).

#### AES-CBC (Cipher Block Chaining)

The CBC mode of operation was patented back in 1976[^5]. In this mode of operation, each block of data is combined with another value using [XOR](https://en.wikipedia.org/wiki/Exclusive_or) before passing through the block cipher. For the first block of plaintext, a unique value called an **initialization vector** (IV) is used, and for each subsequent block of data, the previous block of ciphertext is used. The length of the message must be a multiple of the block size, meaning that shorter messages need to be padded with additional data.

The CBC mode only deals with the _encryption_ of data, providing **confidentiality**, which means that the encrypted message cannot be read by anyone without the secret key. It is not concerned with _authentication_, therefore it needs to be used in combination with a MAC to ensure the integrity and authenticity of a message.

The CBC mode, although undeniably clever, is currently considered insecure and its usage in TLS 1.2 has been deprecated. The most recent revision of TLS, version 1.3, does not use the CBC mode of operation at all. This solves a whole lot of vulnerabilities in the protocol, making it much harder to eavesdrop on TLS-encrypted traffic. TLS 1.3 is therefore banned in China[^6].

#### AES-GCM (Galois Counter Mode)

The Galois Counter Mode (GCM) mode of operation is a much later invention than the CBC mode of operation, with the initial paper by McGrew and Viega[^7] published in 2004[^8].
AES in Galois Counter Mode does not encrypt the data at all.
Instead, for each encrypted message, a unique value is used. The GCM spec calls it an _initialization vector_, just like CBC, but they are also colloquially referred to as **nonces** (short for _number once_).
The IV in GCM does not need to be random. In fact, you can even use sequential numbers, as long as you can guarantee that a given value will never be reused (easier said than done). For AES-GCM, the nonce is _usually_ 96 bits (12 bytes).

GCM is an **authenticated encryption** scheme, meaning that it guarantees not only the privacy of a message, but also its authenticity.
An authenticated encryption scheme therefore seems like a perfect choice for use in cookies.
AES-GCM also supports adding some extra information about the message (e. g. the HTTP origin of the website or the name of the cookie it is stored in).
It is therefore called an **authenticated encryption with associated data** (AEAD) scheme.

GCM differs from CBC in that in GCM mode, you do not encrypt the message, you only encrypt the IV and a counter.
Let me explain how this works in practice.

Let's say your plaintext is 2137 bytes long. With a block size of 16 bytes, we need to encrypt _2137 / 16 = 133.5625 ≈ 134_ blocks of data.
Then, pick a nonce, let's say, the number 42. Encoded in 96 bits, big-endian, it looks like this:

```
00 00 00 00 00 00 00 00 00 00 00 2A
```

The remaining 32 bits of each block contain the block counter. For the first block of plaintext, we use the number 1, and for the last one, the number 134:

```
# first block (index = 1)
00 00 00 00 00 00 00 00 00 00 00 2A 00 00 00 01

# last block (index = 134)
00 00 00 00 00 00 00 00 00 00 00 2A 00 00 00 89
```

In order to encrypt 134 blocks of plaintext, encrypt each of these blocks using the encryption key.
Since the output of AES encryption for a single block is always 16 bytes long, we can calculate that encrypting 134 blocks will yield <em>134 &times; 16 = 2144</em> bytes of random-looking data, which we could probably call a *mask*[^10]. Then, since the resulting binary is longer than the plaintext, we can discard the last 7 bytes of the mask. Then, combine the plaintext with the mask using XOR.

Since XOR is a reversible operation, when decrypting a message encrypted with AES-GCM, we perform the exact same operation to generate the mask, and this mask, combined with the ciphertext using XOR, should return the plaintext.

In contrast with the CBC mode of operation, in which the ciphertext of the previous block is combined with each following block, in GCM mode, there is no dependency between blocks.
This implies that you can compute these in parallel and in any order you want, allowing for all sorts of optimizations.

Now, you may ask: where did the block with the index 0 go?
This block is not used in the encryption process, it is only used for authentication.
If you want to know exactly how this algorithm works, you can read the original proposal by David A. McGrew and John Viega[^7].

### The Random Nonce Problem

As mentioned above, the nonce used in AES-GCM mode is 96 bits long and must not be reused.
In theory, that gives us 2<sup>96</sup> possible nonces, which should be more than enough for unlimited use by all of humanity and [Santi people](https://baike.baidu.com/item/%E4%B8%89%E4%BD%93%E4%BA%BA/8709210) (sorry, link in Chinese), until the [Universe dies of hypothermia](https://en.wikipedia.org/wiki/Heat_death_of_the_universe).
Unfortunately, due to a phenomenon called the [birthday problem](https://en.wikipedia.org/wiki/Birthday_problem), if you generate nonces using a random (or pseudo-random) number generator, the risk of a nonce collision increases greatly.

For this reason, the National Institute of Standards and Technology[^9] recommends that:

> The total number of invocations of the authenticated encryption function shall not exceed
> 2<sup>32</sup>, including all IV lengths and all instances of the authenticated encryption function with
> the given key.

Now, 2<sup>32</sup> is definitely not a small number, but now the risk of a nonce collision is much higher than the original, naïve estimate of 2<sup>&minus;96</sup>.
We could choose to simply ignore this issue. After all, who is going to sit around and submit the login form 2<sup>32</sup> times to trigger a nonce collision in our signed cookie implementation?

We could also implement a key rotation scheme, for instance, rotating the key every _n_ days, to ensure that the 96-bit nonces _really_ do not collide. Now, securely rotating encryption keys is a great challenge in and of itself. Mind you, it may be hard to calculate how _often_, exactly, you would need to rotate the key. If it's just for a side project, the answer is most likely going to be: _never_. However, for some services at scale, the threshold of 2<sup>32</sup> invocations could well be reached within a single day. There ought to be a better way!

### Just Use a Longer Nonce Bro 

Could we just use a longer nonce? The GCM spec does not exactly _force_ us to use 96-bit 

[^1]: As a [rule of thumb](http://browsercookielimits.iain.guru/), the maximum size of all cookies stored for a domain should not exceed around 4 kB (4096 bytes).
[^2]: According to [RFC 6265](https://httpwg.org/specs/rfc6265.html#sane-set-cookie), all the characters permitted within a cookie are: `A`&ndash;`Z`, `a`&ndash;`z`, `0`&ndash;`9`, and the following: <code>!#$%&'()&#x2a;+-./:&lt;=&gt;?@[]^&#x5F;&#x60;{|}~</code>. Note that spaces, double quotes&nbsp;(`"`), and semicolons&nbsp;(`;`) are not permitted.
[^3]: Stuart, A. (2002). *Where cookie comes from.* Retrieved January 14, 2025, from [http://dominopower.com/article/where-cookie-comes-from/](http://dominopower.com/article/where-cookie-comes-from/).
[^4]: If you are tired of obnoxious cookie banners, you can hide them using the browser extension _I still don't care about cookies_ (available for [Chrome/Edge](https://chromewebstore.google.com/detail/i-still-dont-care-about-c/edibdbjcniadpccecjdfdjjppcpchdlm) and [Firefox](https://addons.mozilla.org/en-US/firefox/addon/istilldontcareaboutcookies/)).
[^5]: Ehrsam, W. F., Meyer, C. H. W., Smith, J. L., & Tuchman, W. L. (1976). *Message verification and transmission error detection by block chaining.* US Patent 4074066.
[^6]: Cimpanu, C. (2020). *China is now blocking all encrypted HTTPS traffic that uses TLS 1.3 and ESNI.* ZDNet. Retrieved January 16, 2025, from [https://www.zdnet.com/article/china-is-now-blocking-all-encrypted-https-traffic-using-tls-1-3-and-esni/](https://www.zdnet.com/article/china-is-now-blocking-all-encrypted-https-traffic-using-tls-1-3-and-esni/).
[^7]: McGrew, D. A., & Viega, J. (n.d.). *The Galois/Counter Mode of Operation (GCM).* Retrieved January 17, 2025, from [https://luca-giuzzi.unibs.it/corsi/Support/papers-cryptography/gcm-spec.pdf](https://luca-giuzzi.unibs.it/corsi/Support/papers-cryptography/gcm-spec.pdf).
[^8]: Or maybe 2005. I have not found a conclusive source.
[^9]: Dworkin, M. (2007). *Recommendation for block cipher modes of operation: Galois/Counter Mode (GCM) and GMAC (NIST SP 800-38D).* National Institute of Standards and Technology. Retrieved January 19, 2025, from [https://doi.org/10.6028/NIST.SP.800-38D](https://doi.org/10.6028/NIST.SP.800-38D).
[^10]: I don't think it's an official cryptographic term, but it seems logical enough to me. Then again, _I'm not a lawyer_.
[^11]: Internet Engineering Task Force (IETF). (2015). *RFC 7539: ChaCha20 and Poly1305 for IETF protocols.* Retrieved from [https://www.rfc-editor.org/rfc/rfc7539](https://www.rfc-editor.org/rfc/rfc7539)
